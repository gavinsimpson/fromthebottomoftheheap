--- 
title: "Getting data from the Canada Covid-19 Tracker using R"
date: 2021-01-31 16:49:00
status: publish
layout: post
published: true
type: post
tags:
- "Covid-19"
- API
active: blog
category: R
twitterimg: "getting-data-from-canada-covid-19-tracker-using-r-plot-cases-1.png"
---

```{r setup, echo = FALSE, include = FALSE, cache = FALSE}
## Change the `fig.path` and `cache.path` parts to reflect the new post
render_jekyll()
opts_knit$set(progress = TRUE, base.url = "{{ site.url }}/assets/img/posts/", base.dir = "/home/gavin/work/web/jekyll/blog/assets/img/posts/")
opts_chunk$set(results = "hold",
               fig.path = "getting-data-from-canada-covid-19-tracker-using-r-", 
               comment = NA,
               prompt = FALSE,
               cache = TRUE,
               cache.path = "../_knitr-cache/getting-data-from-canada-covid-19-tracker-using-r-", 
               fig.show = "hold",
               dev = "png",
               dpi = 85,
               tidy = FALSE,
               fig.height = 6,
               fig.width = 8,
               dev.args = list(pointsize = 10),
               fig.lp = "fig:")
```

Last semester (Fall 2020) I taught a new course in healthcare data science for the [Johnson Shoyama Graduate School in Public Policy](https://www.schoolofpublicpolicy.sk.ca/). One of the final topics of the course was querying application programming interfaces (APIs) from within R. The example we used was querying data on the Covid 19 pandemic from the [Covid-19 Tracker Canada](https://covid19tracker.ca), which has a simple API that's easy to work with. In this post I'll show how we accessed the API from within R and converted the query responses into something we can work with easily.

There are many ways of querying APIs in R via a range of packages. Here, I'm going to use **httr** ðŸ“¦ to query the API and **jsonlite** ðŸ“¦ to convert what the API responds to our query with into something more useful. The packages we need are listed in the chunk below --- if you don't have them, uncomment the `install.packages()` line and change `Ncpus` to something suitble for your computer.

```{r package-setup, cache = FALSE, message = FALSE}
pkgs <- c('httr', 'jsonlite', 'dplyr', 'ggplot2', 'purrr')
## install.packages(pkgs, Ncpus = 4)
vapply(pkgs, library, logical(1), logical.return = TRUE, character.only = TRUE)
```

The kind of API we're going to query is a RESTful API --- **RE**presentational **S**tate **T**ransfer. To do the query we need identify the resource we want to query and then send the query using HTTP, the **H**yper**T**ext **T**ransfer **P**rotocol. The resource identity is specified using a uniform resource identifier or URI


![Graphic showing the parts of a URI. Source: Programming Skills for Data Science (Ross & Freeman, 2018)]({{ site.url }}/assets/img/posts/ps4ds-figure-14-2.png)

The URI comprises four parts

1. the protocol
2. the base URI
3. the endpoint
4. additional query parameters

For the Covid-19 Tracker Canada, we'll use the HTTPS protocol for secure HTTP, and its base URI is `api.covid19tracker.ca`. The *endpoint* is the specific location of the data you want to access. For the API we're querying, endpoints include

* `/reports`
* `/cases`
* `/fatalities`
* `/provinces`

Endpoints can also allow multiple sub-resources, these are variables and take the form `:var_name`. For example, the `/reports/province` endpoint allows the province to be specified as a sub-resource. It is documented as `/reports/province/:code`, so we would specify endpoints as `/reports/province/SK` etc, where we are setting `:code` to `SK`.

The final part of the URI are the query parameters and they allow some fine control over what is requested from the endpoint. These are added as key-value pairs, following a `?`, and pairs are separated with `&`. The key is the name of the parameter, and the value is what you want to pass to that parameter. For example, when querying cases, we can specify the province and how many cases are returned per page using

```{r cases-endpoint-example, eval = FALSE}
/cases?province=ON&per_page=50
```

Which endpoints and query parameters are supported are documented in the specific API you are trying to access, so always take some time to familiarise yourself with the API itself. For the Covid-19 Tracker Canada the documentation is also at [api.covid19tracker.ca](https://api.covid19tracker.ca).

It's usually best to build the URI up from these parts stored as separate objects within R

```{r build-uri, message = FALSE}
base  <- "https://api.covid19tracker.ca"
ep    <- "/reports/province/sk"
query <- "?date=2021-01-31"
req   <- paste0(base, ep, query)
req
```

The HTTP request involves using a *verb* and the URI --- here we will use the `GET` verb. In **httr** ðŸ“¦ the `GET` verb is found in the `GET()` function

```{r httr-request}
response <- GET(req)
```

The response consists of two parts

1. the headers
2. the body

The headers contain information about the request and response, while the body contains the result of the query. You can access these components of the response using `headers()` and `content()` respectively.

When you print `response` you'll see a brief summary of the response metadata

```{r print-response}
response
```

The status code is important; 200 means **success** and anything else likely indicates some form of failure. Keep an I on the status code of your queries. If you're wrapping these codes in a function, the `warn_for_status()` and `stop_for_status()` functions to query the status and which throw a warning or an error if the request failed respectively.

The body of the response can be accessed as a generic R list, as the raw bytes of the response, or as plain text. When viewed as text, we see that the text format is JSON

```{r json-content}
jsonlite::prettify(content(response, 'text', encoding = 'UTF-8'))
```

Above, I used the `prettify()` function to display the JSON in a human-readable format. Note also that I'm specifying the encoding explicitly to be UTF-8 as that's what my Linux system uses. If you're not sure about the encoding for your system, just leave the `encoding` argument off and you'll see a message indicating what encoding was used.

To actually parse the JSON into a similar R object we use `jsonlite::fromJSON()`

```{r json-parsed}
parsed <- fromJSON(content(response, 'text', encoding = 'UTF-8'))
str(parsed)
```

What we're most interested in is the `$data` component, but you can see that **jsonlite** ðŸ“¦ has converted the JSON to an R list and where appropriate has converted arrays to data frames, as for `$data` here. Exactly what is returned by the API will be specific to each API, so read the docmentation for the API you want and look at the structure of what is returned to identify the names of relevant components etc.

## Covid-19 cases per day

Now that we've had a crash course in querying an API, let's do something substantive and query the Covid-19 case data for my adopted home province of Saskatchewan. For this we want the `/reports` endpoint and we can specify the province as a sub-resource.

```{r sk-case-data}
base <- 'https://api.covid19tracker.ca'
ep <- '/reports/province/sk'
req <- paste0(base, ep)
response <- GET(req)
cases <- response %>%
  content(as = 'text', encoding = 'UTF-8') %>%
  fromJSON() %>%
  pluck('data') %>%
  as_tibble()
cases
```

At the moment the `date` variable is stored as a simple character vector. If we convert that to a `'Date'` object, **ggplot2** ðŸ“¦ will draw a nicely formatted time axis for us

```{r plot-cases, fig.cap = "", fig.height = 5}
cases %>%
  mutate(date = as.Date(date)) %>%
  ggplot(aes(x = date, y = change_cases)) +
    geom_line() +
    labs(x = NULL, y = 'Cases',
         title = 'Daily Covid-19 cases in Saskatchewan',
         caption = 'Source: N. Little. COVID-19 Tracker Canada (2021), COVID19tracker.ca')
```

Yeah, we're not doing very well in this province ðŸ˜žðŸ¤¬

Hope you enjoyed the post --- if you have comments or questions, ask them in the Comment section below.

### References










